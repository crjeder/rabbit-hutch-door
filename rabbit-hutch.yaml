esphome:
  name: rabbit-hutch

esp32:
  board: esp32doit-devkit-v1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  password: "12345678"

# ota:
#  password: "12345678"

wifi:
  ssid: "12345678"
  password: "12345678"

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rabbit-Hutch Fallback Hotspot"
    password: "12345678"

captive_portal:
    
web_server:
  port: 80 
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Sensor IP address"
    ssid:
      name: "Sensor SSID"
  - platform: version
    name: "Sensor ESPHome Version"

# state machine implementation
external_components:
  - source:
      type: git
      url: https://github.com/muxa/esphome-state-machine

number:
  - platform: template
    id: nr_inhabitants
    initial_value: !lambda |-
      return float(id(nr_rabbits).state);
    min_value: -1.0
    max_value: !lambda |-
      return id(nr_rabbits).state + 1.0;
    step: 1
    optimistic: true
    on_value:
      then:
        - logger.log: value changed
    on_value_range:
      - above: !lambda |-
          return id(nr_rabbit)state + 0.5;
        then:
          - state_machine.transition: ERROR
          - logger.log: Overflow Error! Manual recount necessary.
      - below: -0.5
        then:
          - state_machine.transition: ERROR
          - logger.log: Underflow Error! Manual recount necessary.

state_machine:
  - name: Rabit hutch as state machine
    id: huch_state
    states:
      - "CLOSED"
      - "OPEN"
      - "WAITING"
      - "ERROR"
    inputs:
      - name: MANUAL_OPEN
        transitions:
          - CLOSED -> OPEN
        on_input: 
          - cover.open: hutch_door
          - logger.log: Manual open
      - name: MANUAL_CLOSE
        transitions:
          - ERROR -> CLOSED
          - OPEN -> CLOSED
        on_input: 
          - number.set: 
            id: nr_inhabitants 
            value: !lambda |- 
              return id(nr_rabits).state;
          - cover.close: huch_door
          - logger.log: Manual close
      - name: TIME_CLOSE
        transitions:
          - OPEN -> WAITING
      - name: TIME_OPEN
        transitions:
          - CLOSED -> OPEN
        on_input: 
          - cover.open: hutch_door
          - logger.log: Time open
      - name: ENTER
        transitions:
          - OPEN -> OPEN
          - on_transition: 
              - number.increment:
                id: nr_inhabitants
                cycle: false
          - WAITING -> WAITING
          - on_transition: 
              - number.increment:
                id: nr_inhabitants
                cycle: false
              - then:
                - if:
                  condition:
                    lambda: 'return id(nr_inhabitants).state = it(nr_rabits).state;'
                  then:
                    - state_machine.transition: CLOSE
      - name: CLOSE
        transitions:
          - WAITING -> CLOSED
        on_input:
          - number.set: 
            id: nr_inhabitants 
            value: !lambda |- 
              return id(nr_rabits).state;
          - cover.close: huch_door
          - logger.log: All in! Closing
      - name: EXIT
        transitions:
          - OPEN -> OPEN
          - WAITING -> WAITING
        on_imput: 
          - number.decrement:
            id: inhabitants
            cycle: false
                
switch:
  - platform: gpio
    name: "Hutch Door Open Switch"
    id: door_open_switch
    pin: 
      number: GPIO16
      mode:
        input: true
        pullup: true
    on_turn_on:
      - state_machine.transition: MANUAL_OPEN

  - platform: gpio
    name: "Hutch Door Close Switch"
    id: door_close_switch
    pin: 
      number: GPIO17
      mode:
        input: true
        pullup: true
    on_turn_on:
      - state_machine.transition: MANUAL_CLOSE

output:
  - platform: gpio
    name: "Hutch Door Motor Close"
    id: motor_close
    pin: GPIO33 

  - platform: gpio
    name: "Hutch Door Motor Open"
    id: motor_open
    pin: GPIO32 

cover:
- platform: time_based
  name: "Rabbit Hutch Door"
  id: hutch_door
  open_action:
    - output.turn_on: motor_open 
  open_duration: 10s
  close_action: 
    - output.turn_on: motor_close 
  close_duration: 10s
  stop_action:
      - output.turn_off: motor_close
      - output.turn_off: motor_open
      - state_machine.transition: ERROR

i2c:
  sda: 21
  scl: 22
  scan: false
  id: bus_a
# frequency: 100kHz

apds9960:
  address: 0x39
  update_interval: 60s
  gesture_led_drive: 50mA

sensor:
  - platform: template
    name: "Number of rabits"
    id: nr_rabits
    lambda: |-
        return 4.0; # your constant value here

  - platform: template
    name: "Rabbits in the Hutch"
    id: rabbit_sensor
    lambda: |-
      {return id(inhabitants).state;}

binary_sensor:
  - platform: apds9960
    # Rabbit enters the hutch
    direction: UP
    name: "Rabbit has entered the hutch"
    on_press:
      - number.increment:
          id: inhabitants
          cycle: false
      - state_machine.transition: ENTER

  - platform: apds9960
    direction: DOWN
    name: "Rabbit has left the hutch"
    on_press:
      - number.decrement:
          id: inhabitants
          cycle: false
      - state_machine.transition: EXIT

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Sofia
    servers:
     - 0.pool.ntp.org
     - 1.pool.ntp.org
     - 2.pool.ntp.org
sun:
  latitude: 48.09009° 
  longitude: 11.96109°

  on_sunrise:
    - then:
        - logger.log: Good morning! I'll open the huch door!
        - state_machine.transition: TIME_OPEN

  on_sunset:
    then:
      - logger.log: Good evening! I'll close the huch door!
      - state_machine.transition: TIME_CLOSE

# display:
#   - platform: lcd_pcf8574
#     dimensions: 16x2
#     address: 0x27
#     lambda: |-
#       it.print("Hello World!");
